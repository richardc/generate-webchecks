#!/usr/bin/perl

package Types;
use Moose::Util::TypeConstraints;

subtype 'StrList'
    => as 'ArrayRef[Str]';
coerce  'StrList'
    => from 'Str' => via { [ split /[, ]+/ ] };
no Moose::Util::TypeConstraints;


package Config;
use Moose;

has 'group' => ( is => 'rw', isa => 'HashRef[Group]', required => 1 );
has 'check' => ( is => 'rw', isa => 'HashRef[Check]', required => 1 );
__PACKAGE__->meta->make_immutable;
no Moose;

sub groups {
    my $self = shift;
    return [ values %{ $self->group } ];
}

sub checks {
    my $self = shift;
    return [ values %{ $self->check } ];
}

sub new_from_file {
    my $class = shift;
    my $configfile = shift;
    my $config = Config::Tiny->read( $configfile )
        || die "Failed to open [$configfile]: $Config::Tiny::errstr\n";

    my $self = $class->new({ group => {}, check => {} });

    for my $section ( keys %$config ) {
        my ($type, $name) = split /::/, $section, 2;
        my $class = ucfirst $type;
        my $object = $class->new( {
            %{ $config->{$section} },
            name   => $name,
            config => $self,
        } );
        $self->$type()->{$name} = $object;
    }

    return $self;
}

package Section;
use Moose;
has 'name'    => ( is => 'ro', isa => 'Str', required => 1 );
has 'config'  => ( is => 'ro', isa => 'Config', required => 1 );
__PACKAGE__->meta->make_immutable;
no Moose;

package Check;
use Moose;
extends 'Section';
has 'command' => ( is => 'rw', isa => 'Str', required => 1 );
has 'group' => (
    is       => 'rw',
    isa      => 'StrList',
    coerce   => 1,
    required => 1,
);
__PACKAGE__->meta->make_immutable;
no Moose;

sub groups {
    my $self = shift;
    return [ map { $self->config->group->{$_} } @{ $self->group }]
}
sub hosts {
    my $self = shift;
    return [ map { @{ $_->hosts } } @{ $self->groups } ];
}

package Group;
use Moose;
extends 'Section';
has hosts => (
    is       => 'rw',
    isa      => 'StrList',
    coerce   => 1,
    required => 1,
);
__PACKAGE__->meta->make_immutable;
no Moose;


package main;

use strict;
use warnings;
use Config::Tiny;
use YAML;
use Getopt::Long;
use File::Basename;
use Template;

GetOptions(
    "c|config=s"   => \( my $configfile = 'webchecks.ini' ),
    "d|debug"      => \( my $debug = 0 ),
    "t|template=s" => \( my $template = 'nagios-webchecks.tt'),
);

my $config = Config->new_from_file( $configfile );

my $tt = Template->new();

$tt->process( $template, { 
    checks => $config->checks, sprintf => \&my_sprintf,
} ) || die $tt->error();

sub my_sprintf {
   my ($format, @args) = @_;
   return sprintf $format, @args;
}

